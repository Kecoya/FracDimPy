#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
Test Cantor Set Generation
===========================

Test cases for generating the classic Cantor set using fracDimPy.
The Cantor set is one of the earliest studied fractals, generated by recursively
removing the middle part of line segments, with self-similarity and discontinuity
everywhere.

Theoretical Background:
- Fractal dimension of Cantor set: D = log(2)/log(3) ~= 0.6309
- Each iteration removes middle 1/3, keeps both ends 1/3 each
- The set formed after infinite iterations is uncountable
"""

import numpy as np
import os
import pytest


def test_cantor_set_basic_generation():
    """Test basic Cantor set generation functionality."""
    from fracDimPy import generate_cantor_set

    # Test basic generation with proper length parameter
    level = 6
    length = 3**level
    cantor = generate_cantor_set(level=level, length=length)

    # Test basic properties
    assert len(cantor) == length, f"Expected length {length}, got {len(cantor)}"
    assert cantor.dtype == np.float64 or cantor.dtype == np.float32, "Expected float array"
    assert np.all(np.isfinite(cantor)), "All values should be finite"

    # Test Cantor set properties
    assert np.sum(cantor) > 0, "Should have some retained points"
    assert np.sum(cantor) < len(cantor), "Should not retain all points"

    # Test boundary conditions
    assert cantor[0] > 0, "First point should be retained"
    assert cantor[-1] > 0, "Last point should be retained"

    # Test middle third should be empty at level >= 1
    if level >= 1:
        middle_start = len(cantor) // 3
        middle_end = 2 * len(cantor) // 3
        assert np.all(cantor[middle_start:middle_end] == 0), "Middle third should be empty"


def test_cantor_set_different_levels():
    """Test Cantor set generation at different levels."""
    from fracDimPy import generate_cantor_set

    levels = [0, 1, 2, 3, 4, 5]

    for level in levels:
        # Use appropriate length for each level
        if level == 0:
            length = 1
        else:
            length = 3**level

        cantor = generate_cantor_set(level=level, length=length)

        # Test length property
        assert (
            len(cantor) >= length
        ), f"Level {level}: Expected length at least {length}, got {len(cantor)}"

        # Test monotonic decrease in retained points
        retained_points = np.sum(cantor)
        assert 0 <= retained_points <= len(cantor), f"Level {level}: Invalid retained points count"

        # For level > 0, should have fewer retained points than total
        if level > 0:
            assert retained_points < len(
                cantor
            ), f"Level {level}: Should retain fewer points than total"


def test_cantor_set_self_similarity():
    """Test self-similarity property of Cantor set."""
    from fracDimPy import generate_cantor_set

    level = 4
    cantor = generate_cantor_set(level=level)

    # Test self-similarity: the pattern should repeat
    # The first third and last third should contain scaled copies
    total_length = len(cantor)
    third_length = total_length // 3

    # Extract first and last thirds
    first_third = cantor[:third_length]
    last_third = cantor[2 * third_length :]

    # They should be identical (self-similarity)
    assert np.array_equal(
        first_third, last_third
    ), "First and last thirds should be identical (self-similarity)"


def test_cantor_set_theoretical_properties():
    """Test theoretical properties of Cantor set."""
    from fracDimPy import generate_cantor_set

    # Test with higher level for better approximation
    level = 5
    cantor = generate_cantor_set(level=level)

    retained_points = np.sum(cantor)
    total_points = len(cantor)
    retention_ratio = retained_points / total_points

    # Theoretical retention ratio should be (2/3)^level
    theoretical_ratio = (2 / 3) ** level

    # Allow some tolerance for numerical precision
    assert (
        abs(retention_ratio - theoretical_ratio) < 0.01
    ), f"Retention ratio {retention_ratio:.6f} should be close to theoretical {theoretical_ratio:.6f}"

    # Test theoretical fractal dimension
    theoretical_dim = np.log(2) / np.log(3)
    assert 0.63 < theoretical_dim < 0.64, "Theoretical dimension should be ~0.6309"


def test_cantor_set_edge_cases():
    """Test edge cases for Cantor set generation."""
    from fracDimPy import generate_cantor_set

    # Test level 0 with explicit length
    cantor_0 = generate_cantor_set(level=0, length=1)
    assert len(cantor_0) >= 1, "Level 0 should have at least length 1"
    assert cantor_0[0] > 0, "Level 0 should retain the single point"

    # Test with different levels to ensure robustness
    for level in [1, 2, 7]:
        length = 3**level if level > 0 else 1
        cantor = generate_cantor_set(level=level, length=length)
        assert len(cantor) >= length, f"Level {level}: Length should be at least {length}"
        assert np.sum(cantor) > 0, f"Level {level}: Should have retained points"
