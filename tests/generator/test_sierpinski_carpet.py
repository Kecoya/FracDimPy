#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
Test Sierpinski Carpet Generation
=================================

Test cases for generating Sierpinski carpets using fracDimPy.
The Sierpinski carpet is a two-dimensional generalization of the Sierpinski triangle,
and also a two-dimensional analog of the Menger sponge, generated by recursively
removing the center parts of square grids.

Theoretical Background:
- Fractal dimension of Sierpinski carpet: D = log(8)/log(3) ~= 1.8928
- Divide square into 9 equal parts, remove middle 1, keep surrounding 8
- Two-dimensional analog of Menger sponge
- Fill ratio decreases exponentially as iteration increases
"""

import numpy as np
import os
import pytest


def test_sierpinski_carpet_basic_generation():
    """Test basic Sierpinski carpet generation functionality."""
    from fracDimPy import generate_sierpinski_carpet

    # Test basic generation
    level = 4

    carpet = generate_sierpinski_carpet(level=level)

    # Test basic properties
    expected_size = 3**level
    assert carpet.shape == (expected_size, expected_size), f"Carpet should be {expected_size}x{expected_size}"
    assert carpet.dtype in [np.float64, np.float32, np.uint8, np.bool_], "Valid image dtype expected"
    assert np.all(np.isfinite(carpet)), "All values should be finite"

    # Test image properties
    assert np.any(carpet > 0), "Carpet should contain non-zero values"
    assert np.any(carpet < np.max(carpet)), "Should have variation in values"

    # Test that it's not completely filled or empty
    fill_ratio = np.sum(carpet > 0) / (expected_size * expected_size)
    assert 0.1 < fill_ratio < 0.9, "Fill ratio should be reasonable"


def test_sierpinski_carpet_different_levels():
    """Test Sierpinski carpet generation at different iteration levels."""
    from fracDimPy import generate_sierpinski_carpet

    levels = [0, 1, 2, 3, 4]

    fill_ratios = []
    for level in levels:
        carpet = generate_sierpinski_carpet(level=level)

        # Test basic properties
        expected_size = 3**level
        assert carpet.shape == (expected_size, expected_size), f"Level {level}: Incorrect image size"

        # Calculate fill ratio
        non_zero_pixels = np.sum(carpet > 0)
        fill_ratio = non_zero_pixels / (expected_size * expected_size)
        fill_ratios.append(fill_ratio)

        # Should have some non-zero pixels for all levels
        assert non_zero_pixels > 0, f"Level {level}: Should have non-zero pixels"

    # Test that fill ratio generally decreases with level (approximate)
    # Sierpinski carpet should become sparser as level increases
    for i in range(1, len(levels)):
        # Allow some tolerance due to discretization effects
        assert fill_ratios[i] <= fill_ratios[i-1] * 1.1, \
            f"Fill ratio should generally decrease with level (level {i} vs {i-1})"


def test_sierpinski_carpet_theoretical_properties():
    """Test theoretical properties of Sierpinski carpet."""
    from fracDimPy import generate_sierpinski_carpet

    # Test theoretical fractal dimension
    theoretical_dim = np.log(8) / np.log(3)
    assert 1.89 < theoretical_dim < 1.90, "Theoretical dimension should be ~1.8928"

    # Test theoretical fill ratio: (8/9)^level for continuous case
    level = 4
    carpet = generate_sierpinski_carpet(level=level)

    actual_fill_ratio = np.sum(carpet > 0) / (carpet.shape[0] * carpet.shape[1])
    theoretical_fill_ratio = (8/9) ** level

    # Allow tolerance due to discretization
    assert abs(actual_fill_ratio - theoretical_fill_ratio) < 0.1, \
        f"Actual fill ratio {actual_fill_ratio:.4f} should be close to theoretical {theoretical_fill_ratio:.4f}"


def test_sierpinski_carpet_self_similarity():
    """Test self-similarity property of Sierpinski carpet."""
    from fracDimPy import generate_sierpinski_carpet

    level = 3
    carpet = generate_sierpinski_carpet(level=level)

    # Test self-similarity by checking that the pattern repeats
    # The carpet should have 8-fold symmetry (8 sub-carpets around a hole)
    total_size = carpet.shape[0]
    sub_size = total_size // 3

    # Test that the center is empty (for level >= 1)
    if level >= 1:
        center_start = sub_size
        center_end = 2 * sub_size
        center_region = carpet[center_start:center_end, center_start:center_end]
        assert np.all(center_region == 0), "Center region should be empty"

    # Test that the 8 outer regions contain similar patterns
    positions = [
        (0, 0), (0, sub_size), (0, 2*sub_size),
        (sub_size, 0), (sub_size, 2*sub_size),
        (2*sub_size, 0), (2*sub_size, sub_size), (2*sub_size, 2*sub_size)
    ]

    sub_patterns = []
    for y, x in positions:
        sub_pattern = carpet[y:y+sub_size, x:x+sub_size]
        sub_patterns.append(np.sum(sub_pattern > 0))

    # All 8 sub-patterns should have similar fill ratios
    if len(sub_patterns) >= 2:
        mean_fill = np.mean(sub_patterns)
        for i, fill_count in enumerate(sub_patterns):
            assert abs(fill_count - mean_fill) < mean_fill * 0.5, \
                f"Sub-pattern {i} should have similar fill count to mean"


def test_sierpinski_carpet_edge_cases():
    """Test edge cases for Sierpinski carpet generation."""
    from fracDimPy import generate_sierpinski_carpet

    # Test with level 0 (should be a filled square)
    carpet_0 = generate_sierpinski_carpet(level=0)
    expected_size = 3**0
    assert carpet_0.shape == (expected_size, expected_size), "Level 0 should have size 1x1"
    assert np.sum(carpet_0 > 0) > 0, "Level 0 should have non-zero pixels"

    # Test with level 1
    carpet_1 = generate_sierpinski_carpet(level=1)
    expected_size = 3**1
    assert carpet_1.shape == (expected_size, expected_size), "Level 1 should have size 3x3"

    # Check that center is empty for level 1
    assert carpet_1[1, 1] == 0, "Level 1 center should be empty"
    assert np.sum(carpet_1 > 0) == 8, "Level 1 should have 8 non-zero pixels"


@pytest.mark.parametrize("level", [0, 1, 2, 3, 4])
def test_sierpinski_carpet_level_parameter(level):
    """Test Sierpinski carpet generation with different level parameters."""
    from fracDimPy import generate_sierpinski_carpet

    carpet = generate_sierpinski_carpet(level=level)

    expected_size = 3**level
    assert carpet.shape == (expected_size, expected_size), f"Level {level}: Correct image size"
    assert np.sum(carpet > 0) > 0, f"Level {level}: Should have non-zero pixels"
    assert np.all(np.isfinite(carpet)), f"Level {level}: All values should be finite"

    # Test that higher levels have appropriate fill ratios
    fill_ratio = np.sum(carpet > 0) / (expected_size * expected_size)
    assert 0.01 < fill_ratio < 1.0, f"Level {level}: Fill ratio should be reasonable"


def test_sierpinski_carpet_fill_ratio_properties():
    """Test fill ratio properties across different levels."""
    from fracDimPy import generate_sierpinski_carpet

    levels = [1, 2, 3, 4]

    fill_ratios = []
    for level in levels:
        carpet = generate_sierpinski_carpet(level=level)
        fill_ratio = np.sum(carpet > 0) / (carpet.shape[0] * carpet.shape[1])
        fill_ratios.append(fill_ratio)

        # Should have decreasing fill ratio
        if level > 1:
            theoretical_ratio = (8/9) ** level
            # Allow tolerance for discretization
            assert abs(fill_ratio - theoretical_ratio) < 0.15, \
                f"Level {level}: Fill ratio should be close to theoretical (8/9)^level"

    # Test monotonic decrease
    for i in range(1, len(fill_ratios)):
        assert fill_ratios[i] <= fill_ratios[i-1], \
            f"Fill ratio should decrease with level (level {i} vs {i-1})"