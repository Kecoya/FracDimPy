#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
Test Weierstrass-Mandelbrot (WM) Surface Generation
===================================================

Test cases for generating Weierstrass-Mandelbrot (WM) surfaces using fracDimPy.
The WM surface is a two-dimensional generalization of the WM curve, a continuous but
nowhere differentiable fractal surface generated by superimposing two-dimensional waves
with different frequencies and amplitudes, useful for simulating rough surfaces.

Theoretical Background:
- Fractal dimension of WM surface: D âˆˆ (2, 3)
- Larger D indicates rougher surfaces with greater fluctuations
- Constructed in Fourier series form: superimpose sine waves of different frequencies
- Parameter lambda controls frequency growth rate, typically lambda > 1
- Deterministic fractal surface (different from randomness of FBM)
"""

import numpy as np
import pytest


def test_wm_surface_basic_generation():
    """Test basic WM surface generation functionality."""
    from fracDimPy import generate_wm_surface

    # Test basic generation
    dimension = 2.5
    level = 10
    size = 128
    lambda_param = 1.5

    surface = generate_wm_surface(dimension=dimension, level=level,
                                  size=size, lambda_param=lambda_param)

    # Test basic properties
    assert surface.shape == (size, size), f"Expected shape {(size, size)}, got {surface.shape}"
    assert surface.dtype in [np.float64, np.float32], "Expected float array for surface values"
    assert np.all(np.isfinite(surface)), "All surface values should be finite"

    # Test WM surface properties
    assert surface.min() < surface.max(), "Should have variation in surface values"
    assert len(np.unique(surface)) > 10, "Should have sufficient variation in values"

    # Test parameter bounds
    assert 2 < dimension < 3, f"Fractal dimension {dimension} should be in (2, 3)"
    assert lambda_param > 1, f"Lambda parameter {lambda_param} should be > 1"


def test_wm_surface_different_dimensions():
    """Test WM surface generation with different fractal dimensions."""
    from fracDimPy import generate_wm_surface

    dimensions = [2.1, 2.3, 2.5, 2.7, 2.9]
    level = 8
    size = 64
    lambda_param = 1.5

    std_devs = []
    for dimension in dimensions:
        surface = generate_wm_surface(dimension=dimension, level=level,
                                      size=size, lambda_param=lambda_param)

        # Test basic properties
        assert surface.shape == (size, size), f"Dimension {dimension}: Incorrect shape"
        assert np.all(np.isfinite(surface)), f"Dimension {dimension}: All values should be finite"

        std_dev = surface.std()
        std_devs.append(std_dev)

        # Test dimension bounds
        assert 2 < dimension < 3, f"Dimension {dimension}: Should be in (2, 3)"

    # Test that standard deviation generally increases with fractal dimension
    for i in range(1, len(dimensions)):
        # Higher dimension should generally give higher standard deviation
        assert std_devs[i] > 0, f"Dimension {dimensions[i]}: Should have positive standard deviation"


def test_wm_surface_different_levels():
    """Test WM surface generation with different iteration levels."""
    from fracDimPy import generate_wm_surface

    levels = [5, 8, 12, 15]
    dimension = 2.5
    size = 128
    lambda_param = 1.5

    std_devs = []
    for level in levels:
        surface = generate_wm_surface(dimension=dimension, level=level,
                                      size=size, lambda_param=lambda_param)

        # Test basic properties
        assert surface.shape == (size, size), f"Level {level}: Incorrect shape"
        assert np.all(np.isfinite(surface)), f"Level {level}: All values should be finite"

        std_dev = surface.std()
        std_devs.append(std_dev)

        # Test that surface has variation
        assert surface.min() < surface.max(), f"Level {level}: Should have variation"

    # Test that higher levels generally increase detail
    for std_dev in std_devs:
        assert std_dev > 0, "Should have positive standard deviation at all levels"


def test_wm_surface_different_lambda():
    """Test WM surface generation with different lambda parameters."""
    from fracDimPy import generate_wm_surface

    lambda_params = [1.2, 1.5, 1.8, 2.0]
    dimension = 2.5
    level = 8
    size = 64

    std_devs = []
    for lambda_param in lambda_params:
        surface = generate_wm_surface(dimension=dimension, level=level,
                                      size=size, lambda_param=lambda_param)

        # Test basic properties
        assert surface.shape == (size, size), f"Lambda {lambda_param}: Incorrect shape"
        assert np.all(np.isfinite(surface)), f"Lambda {lambda_param}: All values should be finite"

        std_dev = surface.std()
        std_devs.append(std_dev)

        # Test lambda parameter bounds
        assert lambda_param > 1, f"Lambda {lambda_param}: Should be > 1"

    # Test that different lambda parameters produce different surfaces
    unique_std_devs = len(np.unique(np.round(std_devs, 6)))
    assert unique_std_devs >= 2, "Different lambda parameters should produce different surfaces"


def test_wm_surface_theoretical_properties():
    """Test theoretical properties of WM surface."""
    from fracDimPy import generate_wm_surface

    # Test with specific parameters
    dimension = 2.5
    level = 12
    size = 256
    lambda_param = 1.5

    surface = generate_wm_surface(dimension=dimension, level=level,
                                  size=size, lambda_param=lambda_param)

    # Test dimension bounds
    assert 2.0 < dimension < 3.0, f"Fractal dimension {dimension} should be in (2, 3)"

    # Test lambda parameter
    assert lambda_param > 1.0, f"Lambda parameter {lambda_param} should be > 1.0"

    # Test that surface has expected statistical properties
    mean_val = surface.mean()
    std_val = surface.std()

    # WM surfaces should have reasonable statistical properties
    assert std_val > 0, "Surface should have positive standard deviation"
    assert not np.isnan(mean_val), "Mean should not be NaN"
    assert not np.isnan(std_val), "Standard deviation should not be NaN"

    # Test theoretical properties
    # WM surface should be deterministic and have predictable properties
    assert len(np.unique(surface)) > size, "Should have sufficient variation"


def test_wm_surface_edge_cases():
    """Test edge cases for WM surface generation."""
    from fracDimPy import generate_wm_surface

    # Test with small size
    size = 32
    surface_small = generate_wm_surface(dimension=2.3, level=5,
                                        size=size, lambda_param=1.5)
    assert surface_small.shape == (size, size), "Small size should work"
    assert np.all(np.isfinite(surface_small)), "Small size surface should be finite"
    assert surface_small.std() > 0, "Small size surface should have variation"

    # Test with extreme dimensions
    for dimension in [2.01, 2.99]:
        surface = generate_wm_surface(dimension=dimension, level=8,
                                      size=64, lambda_param=1.5)
        assert surface.shape == (64, 64), f"Dimension {dimension}: Incorrect shape"
        assert np.all(np.isfinite(surface)), f"Dimension {dimension}: All values should be finite"
        assert surface.std() > 0, f"Dimension {dimension}: Should have variation"

    # Test with low level
    level = 3
    surface_low_level = generate_wm_surface(dimension=2.5, level=level,
                                            size=128, lambda_param=1.5)
    assert surface_low_level.shape == (128, 128), "Low level should work"
    assert np.all(np.isfinite(surface_low_level)), "Low level surface should be finite"
    assert surface_low_level.std() > 0, "Low level surface should have variation"

    # Test with extreme lambda
    for lambda_param in [1.1, 3.0]:
        surface = generate_wm_surface(dimension=2.5, level=8,
                                      size=64, lambda_param=lambda_param)
        assert surface.shape == (64, 64), f"Lambda {lambda_param}: Incorrect shape"
        assert np.all(np.isfinite(surface)), f"Lambda {lambda_param}: All values should be finite"
        assert surface.std() > 0, f"Lambda {lambda_param}: Should have variation"


def test_wm_surface_self_similarity():
    """Test self-similarity property of WM surface."""
    from fracDimPy import generate_wm_surface

    dimension = 2.5
    level = 10
    size = 256
    lambda_param = 1.5

    surface = generate_wm_surface(dimension=dimension, level=level,
                                  size=size, lambda_param=lambda_param)

    # Test statistical self-similarity by comparing statistics at different scales
    # This is a simplified test - true self-similarity analysis would be more complex

    # Sample different regions of the surface
    region_size = size // 4
    regions = [
        surface[:region_size, :region_size],
        surface[region_size:2*region_size, region_size:2*region_size],
        surface[-region_size:, -region_size:],
        surface[:region_size, -region_size:],
        surface[-region_size:, :region_size]
    ]

    # Test that different regions have similar statistical properties
    std_devs = [region.std() for region in regions]
    mean_std = np.mean(std_devs)

    # All regions should have similar standard deviations (within tolerance)
    for i, std_dev in enumerate(std_devs):
        assert abs(std_dev - mean_std) < 0.5 * mean_std, \
            f"Region {i}: Standard deviation {std_dev} should be close to mean {mean_std}"


def test_wm_surface_deterministic_properties():
    """Test deterministic properties of WM surface."""
    from fracDimPy import generate_wm_surface

    # WM surface is deterministic (unlike FBM)
    # The same parameters should produce the same result
    dimension = 2.5
    level = 10
    size = 128
    lambda_param = 1.5

    # Generate surface twice with same parameters
    surface1 = generate_wm_surface(dimension=dimension, level=level,
                                   size=size, lambda_param=lambda_param)
    surface2 = generate_wm_surface(dimension=dimension, level=level,
                                   size=size, lambda_param=lambda_param)

    # Test that both are valid
    assert surface1.shape == (size, size), "First surface should have correct shape"
    assert surface2.shape == (size, size), "Second surface should have correct shape"
    assert np.all(np.isfinite(surface1)), "First surface should be finite"
    assert np.all(np.isfinite(surface2)), "Second surface should be finite"

    # Test that both have variation
    assert surface1.std() > 0, "First surface should have variation"
    assert surface2.std() > 0, "Second surface should have variation"

    # Since WM surface is deterministic, results should be identical
    assert np.array_equal(surface1, surface2), "WM surface should be deterministic"


def test_wm_surface_fourier_properties():
    """Test Fourier series properties of WM surface."""
    from fracDimPy import generate_wm_surface

    dimension = 2.5
    level = 8
    size = 128
    lambda_param = 1.5

    surface = generate_wm_surface(dimension=dimension, level=level,
                                  size=size, lambda_param=lambda_param)

    # Test that surface has expected frequency content
    # WM surface is constructed from Fourier series, so should have specific properties

    # Basic frequency analysis (simplified)
    fft_surface = np.fft.fft2(surface)
    fft_magnitude = np.abs(fft_surface)

    # Test that frequency content is not uniform (should have structure)
    # The magnitude should vary across frequencies
    unique_magnitudes = len(np.unique(np.round(fft_magnitude, 6)))
    assert unique_magnitudes > size // 2, "Should have structured frequency content"

    # Test that DC component (mean) is reasonable
    dc_component = fft_magnitude[0, 0]
    assert np.isfinite(dc_component), "DC component should be finite"


@pytest.mark.parametrize("dimension", [2.1, 2.3, 2.5, 2.7, 2.9])
def test_wm_surface_dimension_parameter(dimension):
    """Test WM surface generation with different dimension parameters."""
    from fracDimPy import generate_wm_surface

    level = 8
    size = 64
    lambda_param = 1.5
    surface = generate_wm_surface(dimension=dimension, level=level,
                                  size=size, lambda_param=lambda_param)

    assert surface.shape == (size, size), f"Dimension {dimension}: Correct shape"
    assert np.all(np.isfinite(surface)), f"Dimension {dimension}: All values should be finite"
    assert surface.std() > 0, f"Dimension {dimension}: Should have variation"

    # Test dimension bounds
    assert 2.0 < dimension < 3.0, f"Dimension {dimension}: Should be in valid range"


@pytest.mark.parametrize("level", [5, 8, 12, 15])
def test_wm_surface_level_parameter(level):
    """Test WM surface generation with different level parameters."""
    from fracDimPy import generate_wm_surface

    dimension = 2.5
    size = 128
    lambda_param = 1.5
    surface = generate_wm_surface(dimension=dimension, level=level,
                                  size=size, lambda_param=lambda_param)

    assert surface.shape == (size, size), f"Level {level}: Correct shape"
    assert np.all(np.isfinite(surface)), f"Level {level}: All values should be finite"
    assert surface.std() > 0, f"Level {level}: Should have variation"
    assert surface.min() < surface.max(), f"Level {level}: Should have variation"

    # Test that level affects surface complexity
    unique_values = len(np.unique(np.round(surface, 6)))
    assert unique_values > 10, f"Level {level}: Should have sufficient unique values"


@pytest.mark.parametrize("lambda_param", [1.2, 1.5, 1.8, 2.0])
def test_wm_surface_lambda_parameter(lambda_param):
    """Test WM surface generation with different lambda parameters."""
    from fracDimPy import generate_wm_surface

    dimension = 2.5
    level = 8
    size = 64
    surface = generate_wm_surface(dimension=dimension, level=level,
                                  size=size, lambda_param=lambda_param)

    assert surface.shape == (size, size), f"Lambda {lambda_param}: Correct shape"
    assert np.all(np.isfinite(surface)), f"Lambda {lambda_param}: All values should be finite"
    assert surface.std() > 0, f"Lambda {lambda_param}: Should have variation"

    # Test lambda parameter bounds
    assert lambda_param > 1.0, f"Lambda {lambda_param}: Should be > 1.0"


@pytest.mark.parametrize("size", [32, 64, 128, 256])
def test_wm_surface_size_parameter(size):
    """Test WM surface generation with different size parameters."""
    from fracDimPy import generate_wm_surface

    dimension = 2.5
    level = 8
    lambda_param = 1.5
    surface = generate_wm_surface(dimension=dimension, level=level,
                                  size=size, lambda_param=lambda_param)

    assert surface.shape == (size, size), f"Size {size}: Correct shape"
    assert np.all(np.isfinite(surface)), f"Size {size}: All values should be finite"
    assert surface.std() > 0, f"Size {size}: Should have variation"

    # Test that larger surfaces have more unique values
    unique_values = len(np.unique(np.round(surface, 6)))
    assert unique_values > size, f"Size {size}: Should have sufficient variation"