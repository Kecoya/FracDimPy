#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
Test Sierpinski Triangle Generation
===================================

Test cases for generating Sierpinski triangles using fracDimPy.
The Sierpinski triangle is a classic two-dimensional fractal pattern, generated by
recursively removing the center part of triangles, with perfect self-similarity and
beautiful geometric structure.

Theoretical Background:
- Fractal dimension of Sierpinski triangle: D = log(3)/log(2) ~= 1.585
- Each iteration keeps 3 small triangles, removes the middle one
- As iteration increases, fill ratio gradually decreases toward 0
- Has perfect three-fold symmetry
"""

import numpy as np
import os
import pytest


def test_sierpinski_basic_generation():
    """Test basic Sierpinski triangle generation functionality."""
    from fracDimPy import generate_sierpinski

    # Test basic generation
    level = 5
    size = 512

    triangle = generate_sierpinski(level=level, size=size)

    # Test basic properties
    assert triangle.shape == (size, size), f"Image should be {size}x{size}"
    assert triangle.dtype in [np.float64, np.float32, np.uint8, np.bool_], "Valid image dtype expected"
    assert np.all(np.isfinite(triangle)), "All values should be finite"

    # Test image properties
    assert np.any(triangle > 0), "Triangle should contain non-zero values"
    assert np.any(triangle < np.max(triangle)), "Should have variation in values"

    # Test that it's not completely filled or empty
    fill_ratio = np.sum(triangle > 0) / (size * size)
    assert 0.1 < fill_ratio < 0.9, "Fill ratio should be reasonable"


def test_sierpinski_different_levels():
    """Test Sierpinski triangle generation at different iteration levels."""
    from fracDimPy import generate_sierpinski

    size = 256
    levels = [0, 1, 2, 3, 4, 5]

    fill_ratios = []
    for level in levels:
        triangle = generate_sierpinski(level=level, size=size)

        # Test basic properties
        assert triangle.shape == (size, size), f"Level {level}: Incorrect image size"

        # Calculate fill ratio
        non_zero_pixels = np.sum(triangle > 0)
        fill_ratio = non_zero_pixels / (size * size)
        fill_ratios.append(fill_ratio)

        # Should have some non-zero pixels for all levels
        assert non_zero_pixels > 0, f"Level {level}: Should have non-zero pixels"

    # Test that fill ratio generally decreases with level (approximate)
    # Sierpinski triangle should become sparser as level increases
    for i in range(1, len(levels)):
        # Allow some tolerance due to discretization effects
        assert fill_ratios[i] <= fill_ratios[i-1] * 1.1, \
            f"Fill ratio should generally decrease with level (level {i} vs {i-1})"


def test_sierpinski_theoretical_properties():
    """Test theoretical properties of Sierpinski triangle."""
    from fracDimPy import generate_sierpinski

    # Test theoretical fractal dimension
    theoretical_dim = np.log(3) / np.log(2)
    assert 1.58 < theoretical_dim < 1.59, "Theoretical dimension should be ~1.585"

    # Test theoretical fill ratio: (3/4)^level for continuous case
    size = 512
    level = 4
    triangle = generate_sierpinski(level=level, size=size)

    actual_fill_ratio = np.sum(triangle > 0) / (size * size)
    theoretical_fill_ratio = (3/4) ** level

    # Allow tolerance due to discretization
    assert abs(actual_fill_ratio - theoretical_fill_ratio) < 0.1, \
        f"Actual fill ratio {actual_fill_ratio:.4f} should be close to theoretical {theoretical_fill_ratio:.4f}"


def test_sierpinski_self_similarity():
    """Test self-similarity property of Sierpinski triangle."""
    from fracDimPy import generate_sierpinski

    level = 3
    size = 256

    triangle = generate_sierpinski(level=level, size=size)

    # Test self-similarity by checking that the pattern repeats
    # The triangle should have 3-fold rotational symmetry (approximately)
    center_x, center_y = size // 2, size // 2

    # Get coordinates of non-zero pixels
    non_zero_coords = np.where(triangle > 0)

    if len(non_zero_coords[0]) > 0:
        # Test that the triangle has a reasonable shape
        min_y, max_y = np.min(non_zero_coords[0]), np.max(non_zero_coords[0])
        min_x, max_x = np.min(non_zero_coords[1]), np.max(non_zero_coords[1])

        # Should extend in both directions
        assert max_y - min_y > size // 4, "Triangle should have reasonable height"
        assert max_x - min_x > size // 4, "Triangle should have reasonable width"


def test_sierpinski_symmetry():
    """Test symmetry properties of Sierpinski triangle."""
    from fracDimPy import generate_sierpinski

    level = 2
    size = 256

    triangle = generate_sierpinski(level=level, size=size)

    # Test that the triangle has some symmetry properties
    # Check that it's not just a random pattern
    non_zero_coords = np.where(triangle > 0)

    if len(non_zero_coords[0]) > 0:
        # Get centroid
        centroid_y = np.mean(non_zero_coords[0])
        centroid_x = np.mean(non_zero_coords[1])

        # Should be roughly centered
        assert abs(centroid_y - size // 2) < size // 4, "Should be roughly centered vertically"
        assert abs(centroid_x - size // 2) < size // 4, "Should be roughly centered horizontally"


def test_sierpinski_edge_cases():
    """Test edge cases for Sierpinski triangle generation."""
    from fracDimPy import generate_sierpinski

    # Test with small size
    size = 64
    triangle_small = generate_sierpinski(level=2, size=size)
    assert triangle_small.shape == (size, size), "Small size should work"
    assert np.sum(triangle_small > 0) > 0, "Small size should have non-zero pixels"

    # Test with level 0 (should be a filled triangle)
    triangle_0 = generate_sierpinski(level=0, size=256)
    assert triangle_0.shape == (256, 256), "Level 0 should work"
    assert np.sum(triangle_0 > 0) > 0, "Level 0 should have non-zero pixels"

    # Test with high level
    triangle_high = generate_sierpinski(level=6, size=512)
    assert triangle_high.shape == (512, 512), "High level should work"
    assert np.sum(triangle_high > 0) > 0, "High level should have non-zero pixels"


@pytest.mark.parametrize("level", [0, 1, 2, 3, 4])
def test_sierpinski_level_parameter(level):
    """Test Sierpinski triangle generation with different level parameters."""
    from fracDimPy import generate_sierpinski

    size = 256
    triangle = generate_sierpinski(level=level, size=size)

    assert triangle.shape == (size, size), f"Level {level}: Correct image size"
    assert np.sum(triangle > 0) > 0, f"Level {level}: Should have non-zero pixels"
    assert np.all(np.isfinite(triangle)), f"Level {level}: All values should be finite"

    # Test that higher levels have fewer filled pixels (generally)
    fill_ratio = np.sum(triangle > 0) / (size * size)
    assert 0.01 < fill_ratio < 0.9, f"Level {level}: Fill ratio should be reasonable"


@pytest.mark.parametrize("size", [128, 256, 512])
def test_sierpinski_size_parameter(size):
    """Test Sierpinski triangle generation with different size parameters."""
    from fracDimPy import generate_sierpinski

    level = 3
    triangle = generate_sierpinski(level=level, size=size)

    assert triangle.shape == (size, size), f"Size {size}: Correct image size"
    assert np.sum(triangle > 0) > 0, f"Size {size}: Should have non-zero pixels"
    assert np.all(np.isfinite(triangle)), f"Size {size}: All values should be finite"


def test_sierpinski_fill_ratio_properties():
    """Test fill ratio properties across different levels."""
    from fracDimPy import generate_sierpinski

    size = 512
    levels = [1, 2, 3, 4, 5]

    fill_ratios = []
    for level in levels:
        triangle = generate_sierpinski(level=level, size=size)
        fill_ratio = np.sum(triangle > 0) / (size * size)
        fill_ratios.append(fill_ratio)

        # Should have decreasing fill ratio
        if level > 1:
            theoretical_ratio = (3/4) ** level
            # Allow tolerance for discretization
            assert abs(fill_ratio - theoretical_ratio) < 0.15, \
                f"Level {level}: Fill ratio should be close to theoretical (3/4)^level"

    # Test monotonic decrease
    for i in range(1, len(fill_ratios)):
        assert fill_ratios[i] <= fill_ratios[i-1], \
            f"Fill ratio should decrease with level (level {i} vs {i-1})"
