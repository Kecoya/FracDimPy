#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
Test Weierstrass-Mandelbrot (WM) Curve Generation
==================================================

Test cases for generating Weierstrass-Mandelbrot (WM) curves using fracDimPy.
The WM curve is a generalization of the Weierstrass function, a classic continuous but
nowhere differentiable fractal curve generated by superimposing infinitely many sine waves
with different frequencies and amplitudes.

Theoretical Background:
- Fractal dimension of WM curve: D âˆˆ (1, 2)
- Larger D indicates rougher and more irregular curves
- Constructed in Fourier series form: superimpose sine waves of different frequencies
- Amplitude of each sine wave decays according to power law as frequency increases
- Deterministic fractal curve (different from randomness of FBM)
"""

import numpy as np
import pytest


def test_wm_curve_basic_generation():
    """Test basic WM curve generation functionality."""
    from fracDimPy import generate_wm_curve

    # Test basic generation
    dimension = 1.5
    length = 1024

    x, y = generate_wm_curve(dimension=dimension, length=length)

    # Test basic properties
    assert len(x) == length, f"Expected x length {length}, got {len(x)}"
    assert len(y) == length, f"Expected y length {length}, got {len(y)}"
    assert x.dtype in [np.float64, np.float32], "Expected float array for x coordinates"
    assert y.dtype in [np.float64, np.float32], "Expected float array for y coordinates"
    assert np.all(np.isfinite(x)), "All x values should be finite"
    assert np.all(np.isfinite(y)), "All y values should be finite"

    # Test WM curve properties
    assert y.min() < y.max(), "Should have variation in y values"
    assert len(np.unique(y)) > 10, "Should have sufficient variation in values"

    # Test dimension bounds
    assert 1 < dimension < 2, f"Fractal dimension {dimension} should be in (1, 2)"

    # Test x coordinate range
    assert x.min() >= 0, "X coordinates should be >= 0"
    assert x.max() <= 1.001, f"X coordinates should be <= 1, got {x.max()}"


def test_wm_curve_different_dimensions():
    """Test WM curve generation with different fractal dimensions."""
    from fracDimPy import generate_wm_curve

    dimensions = [1.1, 1.3, 1.5, 1.7, 1.9]
    length = 512

    std_devs = []
    for dimension in dimensions:
        x, y = generate_wm_curve(dimension=dimension, length=length)

        # Test basic properties
        assert len(x) == length, f"Dimension {dimension}: Incorrect x length"
        assert len(y) == length, f"Dimension {dimension}: Incorrect y length"
        assert np.all(np.isfinite(x)), f"Dimension {dimension}: All x values should be finite"
        assert np.all(np.isfinite(y)), f"Dimension {dimension}: All y values should be finite"

        std_dev = y.std()
        std_devs.append(std_dev)

        # Test dimension bounds
        assert 1 < dimension < 2, f"Dimension {dimension}: Should be in (1, 2)"

        # Test x coordinate range
        assert x.min() >= 0, f"Dimension {dimension}: X coordinates should be >= 0"
        assert x.max() <= 1.001, f"Dimension {dimension}: X coordinates should be <= 1"

    # Test that standard deviation generally increases with fractal dimension
    for i in range(1, len(dimensions)):
        # Higher dimension should generally give higher standard deviation
        assert (
            std_devs[i] > 0
        ), f"Dimension {dimensions[i]}: Should have positive standard deviation"


def test_wm_curve_different_lengths():
    """Test WM curve generation with different lengths."""
    from fracDimPy import generate_wm_curve

    lengths = [256, 512, 1024, 2048]
    dimension = 1.5

    for length in lengths:
        x, y = generate_wm_curve(dimension=dimension, length=length)

        # Test basic properties
        assert len(x) == length, f"Length {length}: Incorrect x length"
        assert len(y) == length, f"Length {length}: Incorrect y length"
        assert np.all(np.isfinite(x)), f"Length {length}: All x values should be finite"
        assert np.all(np.isfinite(y)), f"Length {length}: All y values should be finite"

        # Test that curve has variation
        assert y.min() < y.max(), f"Length {length}: Should have variation"
        assert y.std() > 0, f"Length {length}: Should have positive standard deviation"

        # Test x coordinate properties
        assert x.min() >= 0, f"Length {length}: X coordinates should be >= 0"
        assert x.max() <= 1.001, f"Length {length}: X coordinates should be <= 1"


def test_wm_curve_theoretical_properties():
    """Test theoretical properties of WM curve."""
    from fracDimPy import generate_wm_curve

    # Test with specific parameters
    dimension = 1.5
    length = 2048

    x, y = generate_wm_curve(dimension=dimension, length=length)

    # Test dimension bounds
    assert 1.0 < dimension < 2.0, f"Fractal dimension {dimension} should be in (1, 2)"

    # Test that curve has expected statistical properties
    mean_val = y.mean()
    std_val = y.std()

    # WM curves should have reasonable statistical properties
    assert std_val > 0, "Curve should have positive standard deviation"
    assert not np.isnan(mean_val), "Mean should not be NaN"
    assert not np.isnan(std_val), "Standard deviation should not be NaN"

    # Test x coordinate properties
    assert np.abs(x[0]) < 0.001, "First x coordinate should be close to 0"
    assert np.abs(x[-1] - 1.0) < 0.001, "Last x coordinate should be close to 1"

    # Test that x coordinates are monotonically increasing
    x_diffs = np.diff(x)
    assert np.all(x_diffs >= -1e-10), "X coordinates should be monotonically increasing"

    # Test theoretical properties - WM curve should be deterministic
    assert len(np.unique(y)) > length // 10, "Should have sufficient variation"


def test_wm_curve_edge_cases():
    """Test edge cases for WM curve generation."""
    from fracDimPy import generate_wm_curve

    # Test with small length
    length = 256
    x_small, y_small = generate_wm_curve(dimension=1.3, length=length)
    assert len(x_small) == length, "Small length should work"
    assert len(y_small) == length, "Small length should work"
    assert np.all(np.isfinite(x_small)), "Small length x should be finite"
    assert np.all(np.isfinite(y_small)), "Small length y should be finite"
    assert y_small.std() > 0, "Small length curve should have variation"

    # Test with extreme dimensions
    for dimension in [1.01, 1.99]:
        x, y = generate_wm_curve(dimension=dimension, length=512)
        assert len(x) == 512, f"Dimension {dimension}: Incorrect x length"
        assert len(y) == 512, f"Dimension {dimension}: Incorrect y length"
        assert np.all(np.isfinite(x)), f"Dimension {dimension}: All x values should be finite"
        assert np.all(np.isfinite(y)), f"Dimension {dimension}: All y values should be finite"
        assert y.std() > 0, f"Dimension {dimension}: Should have variation"

    # Test with very short length
    length = 128
    x_short, y_short = generate_wm_curve(dimension=1.5, length=length)
    assert len(x_short) == length, "Very short length should work"
    assert len(y_short) == length, "Very short length should work"
    assert np.all(np.isfinite(x_short)), "Very short length x should be finite"
    assert np.all(np.isfinite(y_short)), "Very short length y should be finite"
    assert y_short.std() > 0, "Very short length curve should have variation"


def test_wm_curve_self_similarity():
    """Test self-similarity property of WM curve."""
    from fracDimPy import generate_wm_curve

    dimension = 1.5
    length = 1024

    x, y = generate_wm_curve(dimension=dimension, length=length)

    # Test statistical self-similarity by comparing statistics at different scales
    # This is a simplified test - true self-similarity analysis would be more complex

    # Sample different segments of the curve
    segment_size = length // 4
    segments = [
        (x[:segment_size], y[:segment_size]),
        (x[segment_size : 2 * segment_size], y[segment_size : 2 * segment_size]),
        (x[-segment_size:], y[-segment_size:]),
        (x[:segment_size], y[:segment_size]),  # Duplicate for comparison
    ]

    # Test that different segments have similar statistical properties (scaled)
    std_devs = [seg_y.std() for seg_x, seg_y in segments]
    mean_std = np.mean(std_devs[:3])  # Mean of first three unique segments

    # Segments should have similar standard deviations (within tolerance due to scaling)
    for i, std_dev in enumerate(std_devs[:3]):  # Skip the duplicate
        assert (
            abs(std_dev - mean_std) < 0.5 * mean_std
        ), f"Segment {i}: Standard deviation {std_dev} should be close to mean {mean_std}"


def test_wm_curve_deterministic_properties():
    """Test deterministic properties of WM curve."""
    from fracDimPy import generate_wm_curve

    # WM curve is deterministic (unlike FBM)
    # The same parameters should produce the same result
    dimension = 1.5
    length = 1024

    # Generate curve twice with same parameters
    x1, y1 = generate_wm_curve(dimension=dimension, length=length)
    x2, y2 = generate_wm_curve(dimension=dimension, length=length)

    # Test that both are valid
    assert len(x1) == length, "First curve should have correct x length"
    assert len(y1) == length, "First curve should have correct y length"
    assert len(x2) == length, "Second curve should have correct x length"
    assert len(y2) == length, "Second curve should have correct y length"

    # Test that both have variation
    assert y1.std() > 0, "First curve should have variation"
    assert y2.std() > 0, "Second curve should have variation"

    # Since WM curve is deterministic, results should be identical
    assert np.array_equal(x1, x2), "X coordinates should be identical"
    assert np.array_equal(y1, y2), "Y coordinates should be identical"


def test_wm_curve_fourier_properties():
    """Test Fourier series properties of WM curve."""
    from fracDimPy import generate_wm_curve

    dimension = 1.5
    length = 1024

    x, y = generate_wm_curve(dimension=dimension, length=length)

    # Test that curve has expected frequency content
    # WM curve is constructed from Fourier series, so should have specific properties

    # Basic frequency analysis (simplified)
    fft_y = np.fft.fft(y)
    fft_magnitude = np.abs(fft_y)

    # Test that frequency content is not uniform (should have structure)
    # The magnitude should vary across frequencies
    unique_magnitudes = len(np.unique(np.round(fft_magnitude, 6)))
    assert unique_magnitudes > length // 4, "Should have structured frequency content"

    # Test that DC component (mean) is reasonable
    dc_component = fft_magnitude[0]
    assert np.isfinite(dc_component), "DC component should be finite"

    # Test that high frequency components exist (WM curve should have rich frequency content)
    high_freq_energy = np.sum(fft_magnitude[length // 4 : 3 * length // 4])
    assert high_freq_energy > 0, "Should have energy in high frequencies"


def test_wm_curve_x_coordinates():
    """Test properties of x coordinates in WM curve."""
    from fracDimPy import generate_wm_curve

    dimension = 1.5
    length = 1024

    x, y = generate_wm_curve(dimension=dimension, length=length)

    # Test that x coordinates are in [0, 1]
    assert x.min() >= 0, "X coordinates should be >= 0"
    assert x.max() <= 1.001, f"X coordinates should be <= 1, got {x.max()}"

    # Test that first and last points are close to boundaries
    assert np.abs(x[0]) < 0.01, "First x coordinate should be close to 0"
    assert np.abs(x[-1] - 1.0) < 0.01, "Last x coordinate should be close to 1"

    # Test monotonicity
    x_diffs = np.diff(x)
    assert np.all(x_diffs >= -1e-10), "X coordinates should be monotonically increasing"

    # Test that x coordinates are roughly evenly spaced
    expected_spacing = 1.0 / (length - 1)
    actual_spacing = np.mean(x_diffs[x_diffs > 1e-10])  # Mean of positive differences
    assert (
        np.abs(actual_spacing - expected_spacing) < 0.1 * expected_spacing
    ), f"X spacing {actual_spacing} should be close to expected {expected_spacing}"


def test_wm_curve_continuity():
    """Test continuity properties of WM curve."""
    from fracDimPy import generate_wm_curve

    dimension = 1.5
    length = 2048

    x, y = generate_wm_curve(dimension=dimension, length=length)

    # WM curve should be continuous but nowhere differentiable
    # Test continuity: no jumps or gaps in the curve

    # Test that adjacent points are reasonably close
    y_diffs = np.abs(np.diff(y))
    mean_diff = np.mean(y_diffs)
    max_diff = np.max(y_diffs)

    # Adjacent points should not have huge jumps (continuity test)
    # This is a simplified test - true continuity analysis would be more complex
    assert max_diff < 10 * mean_diff, "Should not have large jumps between adjacent points"

    # Test that there are no NaN or infinite values
    assert not np.any(np.isnan(y)), "Y values should not be NaN"
    assert not np.any(np.isinf(y)), "Y values should not be infinite"

    # Test that the curve is defined everywhere in its domain
    assert len(y) == length, "Curve should be defined for all x values"


@pytest.mark.parametrize("dimension", [1.1, 1.3, 1.5, 1.7, 1.9])
def test_wm_curve_dimension_parameter(dimension):
    """Test WM curve generation with different dimension parameters."""
    from fracDimPy import generate_wm_curve

    length = 512
    x, y = generate_wm_curve(dimension=dimension, length=length)

    assert len(x) == length, f"Dimension {dimension}: Correct x length"
    assert len(y) == length, f"Dimension {dimension}: Correct y length"
    assert np.all(np.isfinite(x)), f"Dimension {dimension}: All x values should be finite"
    assert np.all(np.isfinite(y)), f"Dimension {dimension}: All y values should be finite"
    assert y.std() > 0, f"Dimension {dimension}: Should have variation"

    # Test dimension bounds
    assert 1.0 < dimension < 2.0, f"Dimension {dimension}: Should be in valid range"

    # Test x coordinate properties
    assert x.min() >= 0, f"Dimension {dimension}: X coordinates should be >= 0"
    assert x.max() <= 1.001, f"Dimension {dimension}: X coordinates should be <= 1"


@pytest.mark.parametrize("length", [256, 512, 1024, 2048])
def test_wm_curve_length_parameter(length):
    """Test WM curve generation with different length parameters."""
    from fracDimPy import generate_wm_curve

    dimension = 1.5
    x, y = generate_wm_curve(dimension=dimension, length=length)

    assert len(x) == length, f"Length {length}: Correct x length"
    assert len(y) == length, f"Length {length}: Correct y length"
    assert np.all(np.isfinite(x)), f"Length {length}: All x values should be finite"
    assert np.all(np.isfinite(y)), f"Length {length}: All y values should be finite"
    assert y.std() > 0, f"Length {length}: Should have variation"

    # Test x coordinate bounds
    assert x.min() >= 0, f"Length {length}: X coordinates should be >= 0"
    assert x.max() <= 1.001, f"Length {length}: X coordinates should be <= 1"

    # Test that longer curves have more unique values
    unique_values = len(np.unique(np.round(y, 6)))
    assert unique_values > length // 50, f"Length {length}: Should have sufficient variation"

    # Test continuity for all lengths
    y_diffs = np.abs(np.diff(y))
    assert not np.any(np.isnan(y_diffs)), f"Length {length}: Differences should not be NaN"
    assert not np.any(np.isinf(y_diffs)), f"Length {length}: Differences should not be infinite"
